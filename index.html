<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>실시간 추천 코인 및 매수/매도 비율</title>
  <style>
    /* 기존 스타일 유지 */
    body {
      font-family: sans-serif;
      margin: 30px;
    }
    h1 {
      margin-bottom: 10px;
    }
    button {
      padding: 6px 12px;
      cursor: pointer;
      margin-bottom: 10px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    th, td {
      border: 1px solid #ccc;
      text-align: center;
      padding: 8px;
    }
    thead {
      background: #f3f3f3;
    }
    .loading {
      font-weight: bold;
      color: #007acc;
    }
    .error {
      color: red;
    }
    .highlight-bid {
      background-color: #d4f8d4; /* 매수량이 많으면 녹색 */
    }
    .highlight-ask {
      background-color: #f8d4d4; /* 매도량이 많으면 빨간색 */
    }
    .signal {
      font-weight: bold;
      color: blue; /* 상승 신호 색상 */
    }
    .rank-up {
      color: green;
      font-weight: bold;
    }
    .rank-down {
      color: red;
      font-weight: bold;
    }
    .rank-same {
      color: gray;
    }
    .composite-score {
      font-weight: bold;
      color: #333;
    }
  </style>
</head>
<body>
  <h1>실시간 추천 코인 및 매수/매도 비율</h1>

  <div>
    <button id="refreshBtn">새로고침</button>
    <div id="status" class="loading">불러오는 중...</div>
  </div>

  <!-- 추천 코인 목록 -->
  <h2>추천 코인 (상승률 TOP 5)</h2>
  <table>
    <thead>
      <tr>
        <th>순위</th>
        <th>마켓</th>
        <th>한글 이름</th>
        <th>현재가 (KRW)</th>
        <th>24h 변동률</th>
        <th>매수량</th>
        <th>매도량</th>
        <th>매수/매도 비율</th>
        <th>시장 심리</th>
        <th>상승 신호</th>
      </tr>
    </thead>
    <tbody id="top5TableBody">
      <!-- 추천 코인 데이터 동적으로 추가 -->
    </tbody>
  </table>

  <!-- 두 번째 추천 코인 목록 -->
  <h2>추천 코인 (RSI 과매도 + MACD 골든크로스 + 볼린저 밴드)</h2>
  <p>순위 기준: **종합 매수 신호 점수** (RSI 과매도: 2점, MACD 골든크로스: 2점, 볼린저 밴드 돌파: 1점)</p>
  <table>
    <thead>
      <tr>
        <th>순위</th>
        <th>마켓</th>
        <th>한글 이름</th>
        <th>현재가 (KRW)</th>
        <th>24h 변동률</th>
        <th>매수량</th>
        <th>매도량</th>
        <th>매수/매도 비율</th>
        <th>시장 심리</th>
        <th>상승 신호</th>
        <th>매수 신호</th> <!-- 기존 컬럼 -->
        <th>종합 점수</th> <!-- 기존 컬럼 -->
        <th>순위 변화</th> <!-- 기존 컬럼 -->
      </tr>
    </thead>
    <tbody id="secondTop5TableBody">
      <!-- 두 번째 추천 코인 데이터 동적으로 추가 -->
    </tbody>
  </table>

  <script>
    const marketAllURL = '/.netlify/functions/fetchMarketAll';
    const tickerURL = '/.netlify/functions/fetchTicker';
    const orderBookURL = '/.netlify/functions/fetchOrderBook';
    const candleURL = '/.netlify/functions/fetchCandle'; // 새로운 캔들 데이터 함수 URL

    const refreshBtn = document.getElementById('refreshBtn');
    const statusEl = document.getElementById('status');
    const top5TableBody = document.getElementById('top5TableBody');
    const secondTop5TableBody = document.getElementById('secondTop5TableBody');

    let previousSecondRanks = {}; // 이전 두 번째 추천 코인 순위를 저장

    // 1. 업비트 "전체 마켓 정보" 가져오기
    async function fetchMarketAll() {
      const res = await fetch(marketAllURL);
      if (!res.ok) {
        throw new Error('마켓 정보를 가져오지 못했습니다.');
      }
      return res.json(); // [{market, korean_name, ...}]
    }

    // 2. 업비트 "티커 정보" 가져오기
    async function fetchTicker(markets) {
      const url = `${tickerURL}?markets=${encodeURIComponent(markets.join(','))}`;
      const res = await fetch(url);
      if (!res.ok) {
        throw new Error('티커 정보를 가져오지 못했습니다.');
      }
      return res.json(); // [{market, trade_price, signed_change_rate, ...}]
    }

    // 3. 업비트 "호가 정보" 가져오기
    async function fetchOrderBook(markets) {
      const url = `${orderBookURL}?markets=${encodeURIComponent(markets.join(','))}`;
      const res = await fetch(url);
      if (!res.ok) {
        throw new Error('호가 정보를 가져오지 못했습니다.');
      }
      return res.json(); // [{market, orderbook_units: [{ask_size, bid_size}, ...]}, ...]
    }

    // 4. 업비트 "일별 캔들 정보" 가져오기
    async function fetchCandle(market) {
      try {
        const url = `${candleURL}?market=${encodeURIComponent(market)}`;
        const res = await fetch(url);
        if (!res.ok) {
          throw new Error(`캔들 데이터를 가져오지 못했습니다: ${market}`);
        }
        return await res.json(); // [{market, candle_date_time_utc, high_price, low_price, ...}]
      } catch (error) {
        console.error(error);
        return []; // 빈 배열 반환하여 에러 처리
      }
    }

    // 5. RSI 계산 함수
    function calculateRSI(prices, period = 14) {
      let gains = 0;
      let losses = 0;

      for (let i = 1; i <= period; i++) {
        const change = prices[i] - prices[i - 1];
        if (change > 0) gains += change;
        else losses -= change;
      }

      let avgGain = gains / period;
      let avgLoss = losses / period;
      const rsiValues = [];

      for (let i = period; i < prices.length; i++) {
        const change = prices[i] - prices[i - 1];
        if (change > 0) avgGain = ((avgGain * (period - 1)) + change) / period;
        else avgLoss = ((avgLoss * (period - 1)) - change) / period;

        const rs = avgGain / avgLoss;
        const rsi = 100 - (100 / (1 + rs));
        rsiValues.push(rsi);
      }

      return rsiValues;
    }

    // 6. MACD 계산 함수
    function calculateMACD(prices, shortPeriod = 12, longPeriod = 26, signalPeriod = 9) {
      const shortMA = calculateMovingAverage(prices, shortPeriod);
      const longMA = calculateMovingAverage(prices, longPeriod);

      const macdLine = shortMA.slice(longPeriod - shortPeriod).map((value, index) => value - longMA[index]);
      const signalLine = calculateMovingAverage(macdLine, signalPeriod);
      return { macdLine, signalLine };
    }

    // 7. 이동 평균선 계산 함수
    function calculateMovingAverage(prices, period) {
      const movingAverages = [];
      for (let i = 0; i <= prices.length - period; i++) {
        const subset = prices.slice(i, i + period);
        const average = subset.reduce((sum, price) => sum + price, 0) / period;
        movingAverages.push(average);
      }
      return movingAverages;
    }

    // 8. 볼린저 밴드 계산 함수
    function calculateBollingerBands(prices, period = 20, stdDevMultiplier = 2) {
      const movingAverage = calculateMovingAverage(prices, period);
      const bollingerBands = movingAverage.map((ma, index) => {
        const subset = prices.slice(index, index + period);
        const variance = subset.reduce((sum, price) => sum + Math.pow(price - ma, 2), 0) / period;
        const stdDev = Math.sqrt(variance);
        return {
          upper: ma + stdDevMultiplier * stdDev,
          middle: ma,
          lower: ma - stdDevMultiplier * stdDev
        };
      });
      return bollingerBands;
    }

    // 9. 볼린저 밴드 기반 매수 신호 탐지
    function detectBollingerSignals(prices, bollingerBands) {
      return prices.map((price, index) => {
        if (index < 20) return false; // 볼린저 밴드 계산을 위한 최소 기간
        return price <= bollingerBands[index - 20].lower;
      });
    }

    // 10. 상승 신호 탐지 및 종합 신호 생성
    function detectSignals(prices) {
      const rsiValues = calculateRSI(prices);
      const { macdLine, signalLine } = calculateMACD(prices);
      const bollingerBands = calculateBollingerBands(prices);
      const bollingerSignals = detectBollingerSignals(prices, bollingerBands);

      return prices.map((price, index) => {
        const rsiSignal = rsiValues[index - 14] <= 30 ? 'RSI 과매도' : '';
        const macdSignal = index >= 26 && macdLine[index - 26] > signalLine[index - 26] ? 'MACD 골든크로스' : '';
        const bollingerSignal = bollingerSignals[index] ? '볼린저 밴드 하단 돌파' : '';
        const combinedSignals = [rsiSignal, macdSignal, bollingerSignal].filter(signal => signal !== '');
        const combined = combinedSignals.length > 0 ? combinedSignals.join(', ') : '';
        const compositeScore = 
          (rsiSignal ? 2 : 0) + 
          (macdSignal ? 2 : 0) + 
          (bollingerSignal ? 1 : 0); // 가중치 부여

        return { 
          rsiSignal, 
          macdSignal, 
          bollingerSignal, 
          combined, 
          compositeScore 
        };
      });
    }

    // 11. 최고 및 최저 24h 변동률을 찾는 함수
    function findMaxMinChangeRate(tickers) {
      if (tickers.length === 0) return { max: null, min: null };

      let maxChangeRate = tickers[0].signed_change_rate || tickers[0].change_rate;
      let minChangeRate = tickers[0].signed_change_rate || tickers[0].change_rate;
      let maxTickers = [tickers[0]];
      let minTickers = [tickers[0]];

      tickers.forEach(ticker => {
        const changeRate = ticker.signed_change_rate || ticker.change_rate;
        if (changeRate > maxChangeRate) {
          maxChangeRate = changeRate;
          maxTickers = [ticker];
        } else if (changeRate === maxChangeRate) {
          maxTickers.push(ticker);
        }

        if (changeRate < minChangeRate) {
          minChangeRate = changeRate;
          minTickers = [ticker];
        } else if (changeRate === minChangeRate) {
          minTickers.push(ticker);
        }
      });

      return { max: maxTickers, min: minTickers };
    }

    // 12. 테이블 렌더링
    async function renderTables() {
      try {
        statusEl.textContent = '불러오는 중...';

        const marketData = await fetchMarketAll();
        const krwMarkets = marketData.filter(m => m.market.startsWith('KRW-')).map(m => m.market);
        const tickers = await fetchTicker(krwMarkets);
        const orderBooks = await fetchOrderBook(krwMarkets); // Order Book 데이터 가져오기

        const prices = tickers.map(t => t.trade_price);
        const signals = detectSignals(prices);

        // Ticker 데이터에 Order Book 데이터 결합
        const tickersWithOrderBook = tickers.map(ticker => {
          const orderBook = orderBooks.find(o => o.market === ticker.market);
          return {
            ...ticker,
            orderbook_units: orderBook ? orderBook.orderbook_units : [],
          };
        });

        // 최고 및 최저 24h 변동률 찾기
        const { max, min } = findMaxMinChangeRate(tickersWithOrderBook);

        // 종합 점수 기준으로 추천 코인 정렬 (내림차순)
        const sortedTickers = tickersWithOrderBook
          .map((ticker, index) => ({
            ...ticker,
            compositeScore: signals[index].compositeScore,
            combinedSignals: signals[index].combined,
          }))
          .filter(t => t.compositeScore > 0) // 매수 신호가 있는 코인만 필터링
          .sort((a, b) => b.compositeScore - a.compositeScore || b.change_rate - a.change_rate);

        // 추천 코인 테이블 (상승률 TOP 5)
        top5TableBody.innerHTML = '';
        const top5Tickers = sortedTickers.slice(0, 5);

        // 병렬로 캔들 데이터 가져오기
        const top5CandlePromises = top5Tickers.map(ticker => fetchCandle(ticker.market));
        const top5Candles = await Promise.all(top5CandlePromises);

        top5Tickers.forEach((ticker, index) => {
          const marketInfo = marketData.find(m => m.market === ticker.market);
          
          let totalBid = 0, totalAsk = 0;
          // 매수량과 매도량 계산
          if (ticker.orderbook_units) {
            ticker.orderbook_units.forEach(unit => {
              totalBid += unit.bid_size;
              totalAsk += unit.ask_size;
            });
          }

          // 24h 최고 및 최저 변동률 가져오기
          const candleData = top5Candles[index];
          const highestChangeRate = candleData.length > 0 ? (candleData[0].change_rate || 0) : '-';
          const lowestChangeRate = candleData.length > 0 ? (candleData[0].change_rate || 0) : '-';

          const ratio = totalBid && totalAsk ? (totalBid / totalAsk).toFixed(2) : '-';
          const sentiment = totalBid > totalAsk ? '긍정적' : '부정적';

          const row = `
            <tr>
              <td>${index + 1}</td>
              <td>${ticker.market}</td>
              <td>${marketInfo.korean_name}</td>
              <td>${ticker.trade_price.toLocaleString()}</td>
              <td>${(ticker.change_rate * 100).toFixed(2)}%</td>
              <td>${highestChangeRate !== '-' ? (highestChangeRate * 100).toFixed(2) + '%' : '-'}</td>
              <td>${lowestChangeRate !== '-' ? (lowestChangeRate * 100).toFixed(2) + '%' : '-'}</td>
              <td class="${totalBid > totalAsk ? 'highlight-bid' : ''}">${totalBid.toFixed(2)}</td>
              <td class="${totalAsk > totalBid ? 'highlight-ask' : ''}">${totalAsk.toFixed(2)}</td>
              <td>${ratio}</td>
              <td class="${totalBid > totalAsk ? 'positive' : 'negative'}">${sentiment}</td>
              <td class="signal">${ticker.combinedSignals || '-'}</td>
            </tr>
          `;
          top5TableBody.insertAdjacentHTML('beforeend', row);
        });

        // 두 번째 추천 코인 테이블 (종합 기준)
        secondTop5TableBody.innerHTML = '';
        const recommendedTickers = sortedTickers;

        // 병렬로 캔들 데이터 가져오기
        const secondCandlePromises = recommendedTickers.map(ticker => fetchCandle(ticker.market));
        const secondCandles = await Promise.all(secondCandlePromises);

        const currentSecondRanks = {};

        recommendedTickers.forEach((ticker, index) => {
          currentSecondRanks[ticker.market] = index + 1; // 순위는 1부터 시작
        });

        recommendedTickers.forEach((ticker, index) => {
          const marketInfo = marketData.find(m => m.market === ticker.market);

          let totalBid = 0, totalAsk = 0;
          // 매수량과 매도량 계산
          if (ticker.orderbook_units) {
            ticker.orderbook_units.forEach(unit => {
              totalBid += unit.bid_size;
              totalAsk += unit.ask_size;
            });
          }

          // 24h 최고 및 최저 변동률 가져오기
          const candleData = secondCandles[index];
          const highestChangeRate = candleData.length > 0 ? (candleData[0].change_rate || 0) : '-';
          const lowestChangeRate = candleData.length > 0 ? (candleData[0].change_rate || 0) : '-';

          const ratio = totalBid && totalAsk ? (totalBid / totalAsk).toFixed(2) : '-';
          const sentiment = totalBid > totalAsk ? '긍정적' : '부정적';

          // 이전 순위 가져오기
          const previousRank = previousSecondRanks[ticker.market] || '-';
          let rankChange = '-';
          let rankChangeClass = 'rank-same';

          if (previousRank !== '-' && previousRank !== undefined) {
            const change = previousRank - (index + 1);
            if (change > 0) {
              rankChange = `▲ ${change}`;
              rankChangeClass = 'rank-up';
            } else if (change < 0) {
              rankChange = `▼ ${Math.abs(change)}`;
              rankChangeClass = 'rank-down';
            } else {
              rankChange = '→';
              rankChangeClass = 'rank-same';
            }
          }

          // 매수 신호 결합
          let buySignals = [];
          if (signals[index].rsiSignal) buySignals.push(signals[index].rsiSignal);
          if (signals[index].macdSignal) buySignals.push(signals[index].macdSignal);
          if (signals[index].bollingerSignal) buySignals.push(signals[index].bollingerSignal);
          const buySignalText = buySignals.length > 0 ? buySignals.join(', ') : '-';

          // 종합 점수
          const compositeScore = ticker.compositeScore;

          const row = `
            <tr>
              <td>${index + 1}</td>
              <td>${ticker.market}</td>
              <td>${marketInfo.korean_name}</td>
              <td>${ticker.trade_price.toLocaleString()}</td>
              <td>${(ticker.change_rate * 100).toFixed(2)}%</td>
              <td>${highestChangeRate !== '-' ? (highestChangeRate * 100).toFixed(2) + '%' : '-'}</td>
              <td>${lowestChangeRate !== '-' ? (lowestChangeRate * 100).toFixed(2) + '%' : '-'}</td>
              <td class="${totalBid > totalAsk ? 'highlight-bid' : ''}">${totalBid.toFixed(2)}</td>
              <td class="${totalAsk > totalBid ? 'highlight-ask' : ''}">${totalAsk.toFixed(2)}</td>
              <td>${ratio}</td>
              <td class="${totalBid > totalAsk ? 'positive' : 'negative'}">${sentiment}</td>
              <td class="signal">추천 가능</td>
              <td>${buySignalText}</td> <!-- 매수 신호 표시 -->
              <td class="composite-score">${compositeScore}</td> <!-- 종합 점수 표시 -->
              <td class="${rankChangeClass}">${rankChange}</td> <!-- 순위 변화 표시 -->
            </tr>
          `;
          secondTop5TableBody.insertAdjacentHTML('beforeend', row);
        });

        // 순위 변화 업데이트: 이전 순위 정보를 현재 순위로 갱신
        previousSecondRanks = currentSecondRanks;

        statusEl.textContent = `총 ${krwMarkets.length}개 코인 정보를 불러왔습니다.`;
      } catch (error) {
        console.error(error);
        statusEl.textContent = '오류: ' + error.message;
      }
    }

    // 새로고침 이벤트
    refreshBtn.addEventListener('click', renderTables);

    // 페이지 로드 시 자동 실행
    renderTables();

    // 30초마다 자동 새로고침 (요청 빈도 조절)
    setInterval(renderTables, 30000);
  </script>
</body>
</html>
