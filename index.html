<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>실시간 추천 코인 및 매수/매도 비율</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 30px;
    }
    h1 {
      margin-bottom: 10px;
    }
    button {
      padding: 6px 12px;
      cursor: pointer;
      margin-bottom: 10px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    th, td {
      border: 1px solid #ccc;
      text-align: center;
      padding: 8px;
    }
    thead {
      background: #f3f3f3;
    }
    .loading {
      font-weight: bold;
      color: #007acc;
    }
    .error {
      color: red;
    }
    .highlight-bid {
      background-color: #d4f8d4; /* 매수량이 많으면 녹색 */
    }
    .highlight-ask {
      background-color: #f8d4d4; /* 매도량이 많으면 빨간색 */
    }
    .signal {
      font-weight: bold;
      color: blue; /* 상승 신호 색상 */
    }
    .rank-up {
      color: green;
      font-weight: bold;
    }
    .rank-down {
      color: red;
      font-weight: bold;
    }
    .rank-same {
      color: gray;
    }
    .composite-score {
      font-weight: bold;
      color: #333;
    }
    #changeRateStats {
      margin-bottom: 20px;
      font-weight: bold;
    }
    /* 추가된 스타일 */
    .low-price {
      color: blue;
    }
    .high-price {
      color: red;
    }
    /* 매수 신호가 있는 행을 강조하는 스타일 */
    .buy-signal {
      background-color: #e0ffe0; /* 연한 녹색 배경 */
    }
    /* 매수 신호 아이콘 스타일 */
    .buy-icon {
      color: green;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>실시간 추천 코인 및 매수/매도 비율</h1>

  <div>
    <button id="refreshBtn">새로고침</button>
    <div id="status" class="loading">불러오는 중...</div>
  </div>

  <!-- 최저 및 최고 변동률 표시 -->
  <div id="changeRateStats" style="margin-bottom: 20px; font-weight: bold;">
    <!-- JavaScript에서 업데이트됩니다 -->
  </div>

  <!-- 추천 코인 목록 -->
  <h2>추천 코인 (상승률 TOP 5)</h2>
  <table>
    <thead>
      <tr>
        <th>순위</th>
        <th>마켓</th>
        <th>한글 이름</th>
        <th>현재가 (KRW)</th>
        <th>24h 변동률</th>
        <th>24h 최저가</th> <!-- 새로운 컬럼 추가 -->
        <th>24h 최고가</th> <!-- 새로운 컬럼 추가 -->
        <th>매수량</th>
        <th>매도량</th>
        <th>매수/매도 비율</th>
        <th>시장 심리</th>
        <th>상승 신호</th>
      </tr>
    </thead>
    <tbody id="top5TableBody">
      <!-- 추천 코인 데이터 동적으로 추가 -->
    </tbody>
  </table>

  <!-- 두 번째 추천 코인 목록 -->
  <h2>추천 코인 (RSI 과매도 + MACD 골든크로스)</h2>
  <p>순위 기준: **종합 매수 신호 점수** (RSI 과매도, MACD 골든크로스)</p>
  <table>
    <thead>
      <tr>
        <th>순위</th>
        <th>마켓</th>
        <th>한글 이름</th>
        <th>현재가 (KRW)</th>
        <th>24h 변동률</th>
        <th>24h 최저가</th> <!-- 새로운 컬럼 추가 -->
        <th>24h 최고가</th> <!-- 새로운 컬럼 추가 -->
        <th>매수량</th>
        <th>매도량</th>
        <th>매수/매도 비율</th>
        <th>시장 심리</th>
        <th>상승 신호</th>
        <th>매수 신호</th> <!-- 새로운 컬럼 추가 -->
        <th>종합 점수</th> <!-- 새로운 컬럼 추가 -->
        <th>순위 변화</th> <!-- 새로운 컬럼 추가 -->
      </tr>
    </thead>
    <tbody id="secondTop5TableBody">
      <!-- 두 번째 추천 코인 데이터 동적으로 추가 -->
    </tbody>
  </table>

  <script>
    const marketAllURL = 'https://api.upbit.com/v1/market/all?isDetails=true';
    const tickerURL = 'https://api.upbit.com/v1/ticker?markets=';
    const orderBookURL = 'https://api.upbit.com/v1/orderbook?markets=';

    const refreshBtn = document.getElementById('refreshBtn');
    const statusEl = document.getElementById('status');
    const top5TableBody = document.getElementById('top5TableBody');
    const secondTop5TableBody = document.getElementById('secondTop5TableBody');
    const changeRateStats = document.getElementById('changeRateStats'); // 추가된 요소

    let previousSecondRanks = {}; // 이전 두 번째 추천 코인 순위를 저장
    let notifiedTickers = new Set(); // 알림을 보낸 코인을 추적

    // 1. 업비트 "전체 마켓 정보" 가져오기
    async function fetchMarketAll() {
      const res = await fetch(marketAllURL);
      if (!res.ok) {
        throw new Error('마켓 정보를 가져오지 못했습니다.');
      }
      return res.json(); // [{market, korean_name, ...}]
    }

    // 2. 업비트 "티커 정보" 가져오기
    async function fetchTicker(markets) {
      const url = tickerURL + markets.join(',');
      const res = await fetch(url);
      if (!res.ok) {
        throw new Error('티커 정보를 가져오지 못했습니다.');
      }
      return res.json(); // [{market, trade_price, signed_change_rate, high_price, low_price, ...}]
    }

    // 3. 업비트 "호가 정보" 가져오기
    async function fetchOrderBook(markets) {
      const url = orderBookURL + markets.join(',');
      const res = await fetch(url);
      if (!res.ok) {
        throw new Error('호가 정보를 가져오지 못했습니다.');
      }
      return res.json(); // [{market, orderbook_units: [{ask_size, bid_size}, ...]}, ...]
    }

    // 4. RSI 계산 함수
    function calculateRSI(prices, period = 14) {
      let gains = 0;
      let losses = 0;

      for (let i = 1; i <= period; i++) {
        const change = prices[i] - prices[i - 1];
        if (change > 0) gains += change;
        else losses -= change;
      }

      let avgGain = gains / period;
      let avgLoss = losses / period;
      const rsiValues = [];

      for (let i = period; i < prices.length; i++) {
        const change = prices[i] - prices[i - 1];
        if (change > 0) avgGain = ((avgGain * (period - 1)) + change) / period;
        else avgLoss = ((avgLoss * (period - 1)) - change) / period;

        const rs = avgGain / avgLoss;
        const rsi = 100 - (100 / (1 + rs));
        rsiValues.push(rsi);
      }

      return rsiValues;
    }

    // 5. MACD 계산 함수
    function calculateMACD(prices, shortPeriod = 12, longPeriod = 26, signalPeriod = 9) {
      const shortMA = calculateMovingAverage(prices, shortPeriod);
      const longMA = calculateMovingAverage(prices, longPeriod);

      const macdLine = shortMA.slice(longPeriod - shortPeriod).map((value, index) => value - longMA[index]);
      const signalLine = calculateMovingAverage(macdLine, signalPeriod);
      return { macdLine, signalLine };
    }

    // 6. 이동 평균선 계산 함수
    function calculateMovingAverage(prices, period) {
      const movingAverages = [];
      for (let i = 0; i <= prices.length - period; i++) {
        const subset = prices.slice(i, i + period);
        const average = subset.reduce((sum, price) => sum + price, 0) / period;
        movingAverages.push(average);
      }
      return movingAverages;
    }

    // 7. 볼린저 밴드 계산 함수 (사용 안 함)
    // function calculateBollingerBands(prices, period = 20, stdDevMultiplier = 2) {
    //   const movingAverage = calculateMovingAverage(prices, period);
    //   const bollingerBands = movingAverage.map((ma, index) => {
    //     const subset = prices.slice(index, index + period);
    //     const variance = subset.reduce((sum, price) => sum + Math.pow(price - ma, 2), 0) / period;
    //     const stdDev = Math.sqrt(variance);
    //     return {
    //       upper: ma + stdDevMultiplier * stdDev,
    //       middle: ma,
    //       lower: ma - stdDevMultiplier * stdDev
    //     };
    //   });
    //   return bollingerBands;
    // }

    // 8. 상승 신호 탐지 및 종합 신호 생성 (RSI 과매도와 MACD 골든크로스 모두 만족할 때만 매수 신호)
    function detectSignals(prices) {
      const rsiValues = calculateRSI(prices);
      const { macdLine, signalLine } = calculateMACD(prices);

      return prices.map((price, index) => {
        // RSI 과매도 조건 (RSI <= 30)
        const rsiSignal = rsiValues[index - 14] <= 30 ? 'RSI 과매도' : '';

        // MACD 골든크로스 조건 (MACD > Signal Line)
        const macdSignal = index >= 26 && macdLine[index - 26] > signalLine[index - 26] ? 'MACD 골든크로스' : '';

        // 두 신호가 모두 발생한 경우에만 매수 신호로 간주
        if (rsiSignal && macdSignal) {
          return { 
            rsiSignal, 
            macdSignal, 
            combined: `${rsiSignal}, ${macdSignal}`,
            compositeScore: 2 // 두 신호 모두 만족
          };
        }

        return { 
          rsiSignal: '',
          macdSignal: '',
          combined: '',
          compositeScore: 0
        };
      });
    }

    // 9. 브라우저 알림 함수
    function notifyBuySignal(ticker) {
      if (Notification.permission === 'granted') {
        new Notification('매수 신호 알림', {
          body: `${ticker.korean_name} (${ticker.market}) 에서 RSI 과매도 및 MACD 골든크로스 신호가 발생했습니다.`,
          // icon: 'path_to_icon.png' // 아이콘 경로를 지정하세요 (선택 사항)
        });
      }
    }

    // 알림 권한 요청
    if (Notification.permission !== 'granted' && Notification.permission !== 'denied') {
      Notification.requestPermission().then(permission => {
        if (permission === 'granted') {
          console.log('알림 권한이 허용되었습니다.');
        }
      });
    }

    // 10. 테이블 렌더링
    async function renderTables() {
      try {
        statusEl.textContent = '불러오는 중...';

        const marketData = await fetchMarketAll();
        const krwMarkets = marketData.filter(m => m.market.startsWith('KRW-')).map(m => m.market);
        const tickers = await fetchTicker(krwMarkets);
        const orderBooks = await fetchOrderBook(krwMarkets);

        const prices = tickers.map(t => t.trade_price);
        const signals = detectSignals(prices);

        // 종합 점수 기준으로 추천 코인 정렬 (내림차순)
        const sortedTickers = tickers
          .map((ticker, index) => ({
            ...ticker,
            compositeScore: signals[index].compositeScore,
            combinedSignals: signals[index].combined
          }))
          .filter(t => t.compositeScore > 0) // RSI 과매도와 MACD 골든크로스 모두 있는 코인만 필터링
          .sort((a, b) => b.compositeScore - a.compositeScore || b.signed_change_rate - a.signed_change_rate);

        // 24시간 변동률 최저 및 최고 계산
        const changeRates = sortedTickers.map(t => t.signed_change_rate * 100);
        const minChangeRate = Math.min(...changeRates).toFixed(2);
        const maxChangeRate = Math.max(...changeRates).toFixed(2);

        // 최저 및 최고 변동률 표시
        changeRateStats.textContent = `24시간 변동률 - 최저: ${minChangeRate}%, 최고: ${maxChangeRate}%`;

        // 추천 코인 테이블 (상승률 TOP 5)
        top5TableBody.innerHTML = '';
        const top5Tickers = sortedTickers.slice(0, 5);
        top5Tickers.forEach((ticker, index) => {
          const marketInfo = marketData.find(m => m.market === ticker.market);
          const orderBook = orderBooks.find(o => o.market === ticker.market);

          let totalBid = 0, totalAsk = 0;
          if (orderBook) {
            orderBook.orderbook_units.forEach(unit => {
              totalBid += unit.bid_size;
              totalAsk += unit.ask_size;
            });
          }

          const ratio = totalBid && totalAsk ? (totalBid / totalAsk).toFixed(2) : '-';
          const sentiment = totalBid > totalAsk ? '긍정적' : '부정적';

          const row = `
            <tr>
              <td>${index + 1}</td>
              <td>${ticker.market}</td>
              <td>${marketInfo.korean_name}</td>
              <td>${ticker.trade_price.toLocaleString()}</td>
              <td>${(ticker.signed_change_rate * 100).toFixed(2)}%</td>
              <td class="low-price">${ticker.low_price.toLocaleString()}</td> <!-- 24h 최저가 표시 -->
              <td class="high-price">${ticker.high_price.toLocaleString()}</td> <!-- 24h 최고가 표시 -->
              <td class="${totalBid > totalAsk ? 'highlight-bid' : ''}">${totalBid.toFixed(2)}</td>
              <td class="${totalAsk > totalBid ? 'highlight-ask' : ''}">${totalAsk.toFixed(2)}</td>
              <td>${ratio}</td>
              <td class="${totalBid > totalAsk ? 'positive' : 'negative'}">${sentiment}</td>
              <td class="signal">${ticker.combinedSignals || '-'}</td>
            </tr>
          `;
          top5TableBody.insertAdjacentHTML('beforeend', row);
        });

        // 두 번째 추천 코인 테이블 (RSI 과매도 + MACD 골든크로스)
        secondTop5TableBody.innerHTML = '';
        const recommendedTickers = sortedTickers;

        // 현재 추천 코인의 순위를 저장
        const currentSecondRanks = {};

        recommendedTickers.forEach((ticker, index) => {
          currentSecondRanks[ticker.market] = index + 1; // 순위는 1부터 시작
        });

        recommendedTickers.forEach((ticker, index) => {
          const marketInfo = marketData.find(m => m.market === ticker.market);
          const orderBook = orderBooks.find(o => o.market === ticker.market);

          let totalBid = 0, totalAsk = 0;
          if (orderBook) {
            orderBook.orderbook_units.forEach(unit => {
              totalBid += unit.bid_size;
              totalAsk += unit.ask_size;
            });
          }

          const ratio = totalBid && totalAsk ? (totalBid / totalAsk).toFixed(2) : '-';
          const sentiment = totalBid > totalAsk ? '긍정적' : '부정적';

          // 이전 순위 가져오기
          const previousRank = previousSecondRanks[ticker.market] || '-';
          let rankChange = '-';
          let rankChangeClass = 'rank-same';

          if (previousRank !== '-' && previousRank !== undefined) {
            const change = previousRank - (index + 1);
            if (change > 0) {
              rankChange = `▲ ${change}`;
              rankChangeClass = 'rank-up';
            } else if (change < 0) {
              rankChange = `▼ ${Math.abs(change)}`;
              rankChangeClass = 'rank-down';
            } else {
              rankChange = '→';
              rankChangeClass = 'rank-same';
            }
          }

          // 매수 신호 결합 (RSI 과매도와 MACD 골든크로스)
          let buySignals = [];
          if (signals[index].rsiSignal) buySignals.push(signals[index].rsiSignal);
          if (signals[index].macdSignal) buySignals.push(signals[index].macdSignal);
          const buySignalText = buySignals.length === 2 ? buySignals.join(', ') : '-'; // 두 신호 모두 있을 때만

          // 종합 점수
          const compositeScore = ticker.compositeScore;

          // 매수 신호가 있는 경우 행에 클래스 추가
          const rowClass = buySignals.length === 2 ? 'buy-signal' : '';

          // 매수 신호 아이콘 추가
          const buyIcon = buySignals.length === 2 ? '✅' : '';

          const row = `
            <tr class="${rowClass}">
              <td>${index + 1}</td>
              <td>${ticker.market}</td>
              <td>${marketInfo.korean_name}</td>
              <td>${ticker.trade_price.toLocaleString()}</td>
              <td>${(ticker.signed_change_rate * 100).toFixed(2)}%</td>
              <td class="low-price">${ticker.low_price.toLocaleString()}</td> <!-- 24h 최저가 표시 -->
              <td class="high-price">${ticker.high_price.toLocaleString()}</td> <!-- 24h 최고가 표시 -->
              <td class="${totalBid > totalAsk ? 'highlight-bid' : ''}">${totalBid.toFixed(2)}</td>
              <td class="${totalAsk > totalBid ? 'highlight-ask' : ''}">${totalAsk.toFixed(2)}</td>
              <td>${ratio}</td>
              <td class="${totalBid > totalAsk ? 'positive' : 'negative'}">${sentiment}</td>
              <td class="signal">추천 가능</td>
              <td>${buySignalText} ${buyIcon}</td> <!-- 매수 신호 표시 및 아이콘 추가 -->
              <td class="composite-score">${compositeScore}</td> <!-- 종합 점수 표시 -->
              <td class="${rankChangeClass}">${rankChange}</td> <!-- 순위 변화 표시 -->
            </tr>
          `;
          secondTop5TableBody.insertAdjacentHTML('beforeend', row);

          // 매수 신호가 있는 경우 알림 전송 (중복 방지)
          if (buySignals.length === 2 && !notifiedTickers.has(ticker.market)) {
            notifyBuySignal(ticker);
            notifiedTickers.add(ticker.market);
          }
        });

        // 순위 변화 업데이트: 이전 순위 정보를 현재 순위로 갱신
        previousSecondRanks = currentSecondRanks;

        // 알림된 티커를 정리 (예: 10분 후에 알림된 티커를 제거하여 재알림 가능)
        setTimeout(() => {
          notifiedTickers.clear();
        }, 10 * 60 * 1000); // 10분
        // 위 코드는 10분 후에 알림된 티커 목록을 초기화하여 동일한 코인에 대해 다시 알림을 받을 수 있도록 합니다.

        statusEl.textContent = `총 ${krwMarkets.length}개 코인 정보를 불러왔습니다.`;
      } catch (error) {
        console.error(error);
        statusEl.textContent = '오류: ' + error.message;
      }
    }

    // 새로고침 이벤트
    refreshBtn.addEventListener('click', renderTables);

    // 페이지 로드 시 자동 실행
    renderTables();

    // 5초마다 자동 새로고침
    setInterval(renderTables, 5000);
  </script>
</body>
</html>
